"""
Vulnerability Scanner Service for Security Management Platform
Simplified version without external scanner dependencies for initial setup
"""
import asyncio
import json
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import aiohttp
from ..core.config import settings
from ..core.database import get_db
from ..core.logging import log_scan_event, get_logger
from .llm_service import get_llm_service

logger = get_logger(__name__)


class VulnerabilityScanner:
    """Simplified vulnerability scanner service with mock implementations"""
    
    def __init__(self):
        self.db = get_db()
        self.llm_service = get_llm_service()
        self.active_scans = {}
        self.scanner_configs = {
            "mock": {
                "enabled": True,
                "description": "Mock scanner for testing"
            }
        }
    
    async def start_scan(self, scan_config: Dict[str, Any]) -> Dict[str, Any]:
        """Start a vulnerability scan"""
        try:
            scan_id = str(uuid.uuid4())
            scanner_type = scan_config.get("scanner_type", "mock")
            target = scan_config.get("target", "")
            scan_type = scan_config.get("scan_type", "quick")
            
            # Create scan record
            scan_record = {
                "id": scan_id,
                "target": target,
                "scanner_type": scanner_type,
                "scan_type": scan_type,
                "status": "running",
                "start_time": datetime.now().isoformat(),
                "end_time": None,
                "progress": 0,
                "vulnerabilities": [],
                "summary": {},
                "config": scan_config
            }
            
            # Store scan record
            self.db.create("scan_results", scan_record)
            self.active_scans[scan_id] = scan_record
            
            # Log scan start
            log_scan_event(scan_id, scanner_type, target, "started")
            
            # Start mock scan
            asyncio.create_task(self._run_mock_scan(scan_id, scan_config))
            
            return {
                "scan_id": scan_id,
                "status": "started",
                "message": f"Mock scan started for {target}"
            }
            
        except Exception as e:
            logger.error(f"Error starting scan: {e}")
            raise
    
    async def _run_mock_scan(self, scan_id: str, config: Dict[str, Any]):
        """Run vulnerability scan (including vulnerable server scan)"""
        try:
            target = config.get("target", "")
            scan_type = config.get("scan_type", "quick")
            
            # Simulate scan progress
            await self._update_scan_progress(scan_id, 10, "Initializing scan...")
            await asyncio.sleep(1)
            
            vulnerabilities = []
            
            # Check if target is localhost:5000 (vulnerable server)
            if "localhost:5000" in target or "127.0.0.1:5000" in target:
                await self._update_scan_progress(scan_id, 30, "Scanning vulnerable server...")
                vulnerabilities.extend(await self._scan_vulnerable_server())
                await asyncio.sleep(2)
            else:
                await self._update_scan_progress(scan_id, 30, "Scanning network ports...")
                await asyncio.sleep(2)
            
            await self._update_scan_progress(scan_id, 60, "Analyzing services...")
            await asyncio.sleep(1)
            
            await self._update_scan_progress(scan_id, 80, "Checking for vulnerabilities...")
            
            # Add simulated vulnerabilities if needed
            if not vulnerabilities:
                vulnerabilities = self._generate_simulated_vulnerabilities(target, scan_type)
            
            await asyncio.sleep(1)
            
            await self._update_scan_progress(scan_id, 90, "Generating report...")
            await asyncio.sleep(1)
            
            # Generate summary
            summary = self._generate_scan_summary(vulnerabilities)
            
            await self._complete_scan(scan_id, vulnerabilities, summary)
            
        except Exception as e:
            await self._fail_scan(scan_id, str(e))
    
    def _generate_simulated_vulnerabilities(self, target: str, scan_type: str) -> List[Dict[str, Any]]:
        """Generate simulated vulnerability results"""
        base_vulns = [
            {
                "id": "CVE-2023-1234",
                "title": "SQL Injection Vulnerability",
                "description": "The application is vulnerable to SQL injection attacks",
                "severity": "high",
                "cvss_score": 8.5,
                "port": 80,
                "service": "http",
                "protocol": "tcp",
                "status": "open",
                "evidence": "SQL injection payload executed successfully",
                "recommendation": "Use parameterized queries and input validation",
                "cwe_id": "CWE-89",
                "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1234"]
            },
            {
                "id": "CVE-2023-5678",
                "title": "Cross-Site Scripting (XSS)",
                "description": "Reflected XSS vulnerability in search functionality",
                "severity": "medium",
                "cvss_score": 6.1,
                "port": 443,
                "service": "https",
                "protocol": "tcp",
                "status": "open",
                "evidence": "XSS payload reflected in response",
                "recommendation": "Implement proper output encoding and CSP headers",
                "cwe_id": "CWE-79",
                "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-5678"]
            },
            {
                "id": "CVE-2023-9012",
                "title": "Weak SSL/TLS Configuration",
                "description": "Server supports weak SSL/TLS protocols",
                "severity": "medium",
                "cvss_score": 5.8,
                "port": 443,
                "service": "https",
                "protocol": "tcp",
                "status": "open",
                "evidence": "SSLv3 and TLS 1.0 supported",
                "recommendation": "Disable weak protocols, use TLS 1.2+ only",
                "cwe_id": "CWE-327",
                "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-9012"]
            }
        ]
        
        # Add more vulnerabilities for comprehensive scans
        if scan_type == "comprehensive":
            base_vulns.extend([
                {
                    "id": "CVE-2023-3456",
                    "title": "Directory Traversal",
                    "description": "Path traversal vulnerability in file upload",
                    "severity": "high",
                    "cvss_score": 7.5,
                    "port": 80,
                    "service": "http",
                    "protocol": "tcp",
                    "status": "open",
                    "evidence": "Successfully accessed files outside web root",
                    "recommendation": "Validate and sanitize file paths",
                    "cwe_id": "CWE-22",
                    "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-3456"]
                },
                {
                    "id": "CVE-2023-7890",
                    "title": "Default Credentials",
                    "description": "Default admin credentials found",
                    "severity": "critical",
                    "cvss_score": 9.8,
                    "port": 22,
                    "service": "ssh",
                    "protocol": "tcp",
                    "status": "open",
                    "evidence": "Default username/password combination works",
                    "recommendation": "Change default credentials immediately",
                    "cwe_id": "CWE-798",
                    "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-7890"]
                }
            ])
        
        return base_vulns
    
    async def _scan_vulnerable_server(self) -> List[Dict[str, Any]]:
        """Scan vulnerable server for real vulnerabilities"""
        try:
            vulnerabilities = []
            
            # Create HTTP session
            session = aiohttp.ClientSession()
            
            # Fetch vulnerabilities from vulnerable server API
            try:
                async with session.get("http://localhost:5000/api/vulnerabilities") as response:
                    if response.status == 200:
                        data = await response.json()
                        vuln_events = data.get("vulnerabilities", [])
                        
                        for vuln in vuln_events:
                            if vuln.get("exploit_success"):
                                vulnerability = {
                                    "id": vuln.get("cve_id", f"VULN-{vuln['id']}"),
                                    "title": f"{vuln['event_type']} - {vuln['description']}",
                                    "description": vuln["description"],
                                    "severity": vuln["severity"].lower(),
                                    "cvss_score": {
                                        "Critical": 9.5,
                                        "High": 7.8,
                                        "Medium": 5.5,
                                        "Low": 2.3
                                    }.get(vuln["severity"], 5.0),
                                    "port": 5000,
                                    "service": "http",
                                    "protocol": "tcp",
                                    "status": "exploited",
                                    "evidence": f"Payload: {vuln.get('payload', 'N/A')}",
                                    "recommendation": self._get_vulnerability_recommendation(vuln["event_type"]),
                                    "cwe_id": self._get_cwe_id(vuln["event_type"]),
                                    "nvd_status": "Published",  # Added required field
                                    "references": [f"http://localhost:5000{vuln.get('target_endpoint', '')}"],
                                    "source_ip": vuln.get("source_ip", ""),
                                    "user_agent": vuln.get("user_agent", ""),
                                    "timestamp": vuln["created_at"]
                                }
                                vulnerabilities.append(vulnerability)
                        
            except Exception as e:
                logger.error(f"Error fetching vulnerabilities from vulnerable server: {e}")
            
            # Fetch active threats
            try:
                async with session.get("http://localhost:5000/api/threats") as response:
                    if response.status == 200:
                        data = await response.json()
                        threats = data.get("active_threats", [])
                        
                        for threat in threats:
                            if threat.get("is_active"):
                                vulnerability = {
                                    "id": f"THREAT-{threat['threat_id'][:8]}",
                                    "title": f"{threat['threat_type']} - {threat['description']}",
                                    "description": threat["description"],
                                    "severity": threat["severity"].lower(),
                                    "cvss_score": {
                                        "Critical": 9.2,
                                        "High": 7.5,
                                        "Medium": 5.8,
                                        "Low": 3.1
                                    }.get(threat["severity"], 5.0),
                                    "port": 5000,
                                    "service": "http",
                                    "protocol": "tcp",
                                    "status": "active",
                                    "evidence": f"Active threat detected. Payload: {threat.get('payload', 'N/A')}",
                                    "recommendation": self._get_vulnerability_recommendation(threat["threat_type"]),
                                    "cwe_id": self._get_cwe_id(threat["threat_type"]),
                                    "references": [f"http://localhost:5000{threat.get('target_endpoint', '')}"],
                                    "detection_count": threat.get("detection_count", 1),
                                    "timestamp": threat["created_at"]
                                }
                                vulnerabilities.append(vulnerability)
                        
            except Exception as e:
                logger.error(f"Error fetching threats from vulnerable server: {e}")
            
            # Test specific endpoints for vulnerabilities
            test_vulnerabilities = await self._test_vulnerable_endpoints(session)
            vulnerabilities.extend(test_vulnerabilities)
            
            await session.close()
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error scanning vulnerable server: {e}")
            return []
    
    async def _test_vulnerable_endpoints(self, session: aiohttp.ClientSession) -> List[Dict[str, Any]]:
        """Test specific endpoints for vulnerabilities"""
        vulnerabilities = []
        
        # Test SQL injection
        try:
            async with session.get("http://localhost:5000/search?q=' OR 1=1 --") as response:
                if response.status == 200:
                    vulnerabilities.append({
                        "id": "SQL-INJ-001",
                        "title": "SQL Injection in Search Functionality",
                        "description": "SQL injection vulnerability detected in search parameter",
                        "severity": "high",
                        "cvss_score": 8.2,
                        "port": 5000,
                        "service": "http",
                        "protocol": "tcp",
                        "status": "confirmed",
                        "evidence": "SQL injection payload ' OR 1=1 -- executed successfully",
                        "recommendation": "Use parameterized queries and input validation",
                        "cwe_id": "CWE-89",
                        "references": ["http://localhost:5000/search"]
                    })
        except:
            pass
        
        # Test XSS vulnerability
        try:
            payload = "<script>alert('XSS')</script>"
            form_data = aiohttp.FormData()
            form_data.add_field('title', f'XSS Test {payload}')
            form_data.add_field('content', payload)
            
            async with session.post("http://localhost:5000/add_post", data=form_data) as response:
                if response.status in [200, 302]:
                    vulnerabilities.append({
                        "id": "XSS-001",
                        "title": "Cross-Site Scripting (XSS) in Post Content",
                        "description": "XSS vulnerability detected in post content",
                        "severity": "medium",
                        "cvss_score": 6.1,
                        "port": 5000,
                        "service": "http",
                        "protocol": "tcp",
                        "status": "confirmed",
                        "evidence": f"XSS payload {payload} injected successfully",
                        "recommendation": "Implement proper output encoding and CSP headers",
                        "cwe_id": "CWE-79",
                        "references": ["http://localhost:5000/add_post"]
                    })
        except:
            pass
        
        # Test command injection
        try:
            async with session.get("http://localhost:5000/ping?host=localhost; whoami") as response:
                if response.status == 200:
                    vulnerabilities.append({
                        "id": "CMD-INJ-001",
                        "title": "Command Injection in Ping Functionality",
                        "description": "Command injection vulnerability detected in ping parameter",
                        "severity": "critical",
                        "cvss_score": 9.8,
                        "port": 5000,
                        "service": "http",
                        "protocol": "tcp",
                        "status": "confirmed",
                        "evidence": "Command injection payload 'localhost; whoami' executed",
                        "recommendation": "Sanitize input and avoid shell command execution",
                        "cwe_id": "CWE-78",
                        "references": ["http://localhost:5000/ping"]
                    })
        except:
            pass
        
        # Test information disclosure
        try:
            async with session.get("http://localhost:5000/api/users") as response:
                if response.status == 200:
                    data = await response.json()
                    if data.get("users"):
                        vulnerabilities.append({
                            "id": "INFO-DISC-001",
                            "title": "Information Disclosure - User Data Exposed",
                            "description": "API endpoint exposes sensitive user data including passwords",
                            "severity": "high",
                            "cvss_score": 7.5,
                            "port": 5000,
                            "service": "http",
                            "protocol": "tcp",
                            "status": "confirmed",
                            "evidence": f"Exposed {len(data['users'])} user records with passwords",
                            "recommendation": "Remove sensitive data from API responses",
                            "cwe_id": "CWE-200",
                            "references": ["http://localhost:5000/api/users"]
                        })
        except:
            pass
        
        return vulnerabilities
    
    def _get_vulnerability_recommendation(self, vuln_type: str) -> str:
        """Get recommendation for vulnerability type"""
        recommendations = {
            "SQL_INJECTION_ATTEMPT": "Use parameterized queries and input validation",
            "XSS_ATTEMPT": "Implement proper output encoding and CSP headers",
            "COMMAND_INJECTION_ATTEMPT": "Sanitize input and avoid shell command execution",
            "INFO_DISCLOSURE_ATTEMPT": "Remove sensitive data from API responses",
            "AUTHENTICATION_FAILURE": "Implement account lockout and strong password policies",
            "SQL Injection": "Use parameterized queries and input validation",
            "Cross-Site Scripting": "Implement proper output encoding and CSP headers",
            "Command Injection": "Sanitize input and avoid shell command execution",
            "Information Disclosure": "Remove sensitive data from API responses"
        }
        return recommendations.get(vuln_type, "Apply security best practices")
    
    def _get_cwe_id(self, vuln_type: str) -> str:
        """Get CWE ID for vulnerability type"""
        cwe_ids = {
            "SQL_INJECTION_ATTEMPT": "CWE-89",
            "XSS_ATTEMPT": "CWE-79",
            "COMMAND_INJECTION_ATTEMPT": "CWE-78",
            "INFO_DISCLOSURE_ATTEMPT": "CWE-200",
            "AUTHENTICATION_FAILURE": "CWE-287",
            "SQL Injection": "CWE-89",
            "Cross-Site Scripting": "CWE-79",
            "Command Injection": "CWE-78",
            "Information Disclosure": "CWE-200"
        }
        return cwe_ids.get(vuln_type, "CWE-Other")
    
    def _generate_scan_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate scan summary"""
        total_vulns = len(vulnerabilities)
        critical_vulns = len([v for v in vulnerabilities if v.get("severity") == "critical"])
        high_vulns = len([v for v in vulnerabilities if v.get("severity") == "high"])
        medium_vulns = len([v for v in vulnerabilities if v.get("severity") == "medium"])
        low_vulns = len([v for v in vulnerabilities if v.get("severity") == "low"])
        
        # Calculate risk score (0-100)
        risk_score = min(100, (critical_vulns * 25) + (high_vulns * 15) + (medium_vulns * 8) + (low_vulns * 3))
        
        return {
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "high_vulnerabilities": high_vulns,
            "medium_vulnerabilities": medium_vulns,
            "low_vulnerabilities": low_vulns,
            "risk_score": risk_score,
            "risk_level": "high" if risk_score > 50 else "medium" if risk_score > 20 else "low",
            "scan_duration": "00:02:30",
            "ports_scanned": 1000,
            "services_found": len(set(v.get("service", "") for v in vulnerabilities))
        }
    
    async def _update_scan_progress(self, scan_id: str, progress: int, message: str):
        """Update scan progress"""
        if scan_id in self.active_scans:
            self.active_scans[scan_id]["progress"] = progress
            self.active_scans[scan_id]["status_message"] = message
            
            # Update in database
            self.db.update("scan_results", scan_id, {
                "progress": progress,
                "status_message": message
            })
    
    async def _complete_scan(self, scan_id: str, vulnerabilities: List[Dict[str, Any]], summary: Dict[str, Any]):
        """Complete the scan"""
        if scan_id in self.active_scans:
            scan_record = self.active_scans[scan_id]
            scan_record.update({
                "status": "completed",
                "end_time": datetime.now().isoformat(),
                "progress": 100,
                "vulnerabilities": vulnerabilities,
                "summary": summary,
                "status_message": "Scan completed successfully"
            })
            
            # Update in database
            self.db.update("scan_results", scan_id, scan_record)
            
            # Log completion
            log_scan_event(scan_id, scan_record["scanner_type"], scan_record["target"], "completed")
            
            logger.info(f"Scan {scan_id} completed with {len(vulnerabilities)} vulnerabilities")
    
    async def _fail_scan(self, scan_id: str, error: str):
        """Mark scan as failed"""
        if scan_id in self.active_scans:
            scan_record = self.active_scans[scan_id]
            scan_record.update({
                "status": "failed",
                "end_time": datetime.now().isoformat(),
                "error": error,
                "status_message": f"Scan failed: {error}"
            })
            
            # Update in database
            self.db.update("scan_results", scan_id, scan_record)
            
            # Log failure
            log_scan_event(scan_id, scan_record["scanner_type"], scan_record["target"], "failed")
            
            logger.error(f"Scan {scan_id} failed: {error}")
    
    async def get_scan_status(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Get scan status"""
        # Check active scans first
        if scan_id in self.active_scans:
            return self.active_scans[scan_id]
        
        # Check database
        return self.db.get("scan_results", scan_id)
    
    async def get_all_scans(self) -> List[Dict[str, Any]]:
        """Get all scans"""
        # Combine active scans with database scans
        db_scans = self.db.get_all("scan_results")
        active_scan_ids = set(self.active_scans.keys())
        
        # Update active scans in results
        for scan in db_scans:
            if scan["id"] in active_scan_ids:
                scan.update(self.active_scans[scan["id"]])
        
        return db_scans
    
    async def cancel_scan(self, scan_id: str) -> bool:
        """Cancel an active scan"""
        if scan_id in self.active_scans:
            scan_record = self.active_scans[scan_id]
            scan_record.update({
                "status": "cancelled",
                "end_time": datetime.now().isoformat(),
                "status_message": "Scan cancelled by user"
            })
            
            # Update in database
            self.db.update("scan_results", scan_id, scan_record)
            
            # Remove from active scans
            del self.active_scans[scan_id]
            
            # Log cancellation
            log_scan_event(scan_id, scan_record["scanner_type"], scan_record["target"], "cancelled")
            
            return True
        
        return False
    
    def get_scanner_status(self) -> Dict[str, Any]:
        """Get scanner status"""
        return {
            "scanners": self.scanner_configs,
            "active_scans": len(self.active_scans),
            "total_scans": len(self.db.get_all("scan_results")),
            "status": "operational"
        }
    
    def _get_scanner_capabilities(self, scanner_name: str) -> List[str]:
        """Get scanner capabilities"""
        capabilities = {
            "mock": [
                "port_scanning",
                "vulnerability_detection",
                "service_identification",
                "risk_assessment"
            ]
        }
        return capabilities.get(scanner_name, [])


# Global scanner service instance
_scanner_service = None

def get_scanner_service() -> VulnerabilityScanner:
    """Get or create scanner service instance"""
    global _scanner_service
    if _scanner_service is None:
        _scanner_service = VulnerabilityScanner()
    return _scanner_service 